setenv C ../hycom_97WI
foreach f ( Makefile Make.csh )
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -bw Makefile ../hycom_97WI
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -bw Make.csh ../hycom_97WI
17c17
< #setenv ARCH Aintelsse-pe-sm-relo
---
> #setenv ARCH intelsse-pe-sm-relo
19,22c19,23
< #module swap compiler compiler/intel/12.1.3
< #module swap mpi      mpi/intel/impi/4.1.0
< #module list
< #setenv ARCH Aintelsse-impi-sm-relo
---
> module swap compiler compiler/intel/12.1.3
> module swap mpi      mpi/intel/impi/4.1.0
> module list
> setenv ARCH intelsse-impi-sm-relo
> #setenv ARCH intelsse-impi-sm-SD-relo
25,26c26,29
< module list
< setenv ARCH Axc30-intel-relo
---
> #module list
> #setenv ARCH xc30-intel-relo
> #
> #setenv ARCH intel-pgi-SD-relo
end
foreach f ( *.h *.c )
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw dimensions.h ../hycom_97WI
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw dimensions_relo.h ../hycom_97WI
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_xc_mp.h ../hycom_97WI
279c279
<       real*4,  intent(out)   :: aa(itdm,*)
---
>       real*4,  intent(out)   :: aa(itdm,jtdm)
291a292
> c        = 0; all nodes
294,298c295
< c  4) The size of aa depends on mnflg
< c      =-1; aa needed on 1st node in each row, dimension (itdm,jdm)
< c      = n; aa needed on nth node,             dimension (itdm,jtdm)
< c
< c  5) parameters:
---
> c  4) parameters:
322,323c319
<       if     (.not.allocated(at4)) then
<         if     (mproc.eq.mpe_1(nproc)) then
---
>       if     (.not.allocated(al4)) then
325d320
<           allocate(      alt4(idm*jdm,ipr) )
327,328d321
<           call mem_stat_add( (idm *jdm*jpr)/2 ) !real*4, so /2
<         endif !first tile in the row
402c395
<               aa(i,j) = al4(i,j)
---
>               aa(i,j+j0) = al4(i,j)
438a432,436
> c
>       if     (mnflg.eq.0) then
>         call mpi_bcast(aa,itdm*jtdm,MTYPE4,
>      &                 idproc1(1),mpi_comm_hycom,mpierr)
>       endif
440c438
<       if     (mnproc.eq.mnflg) then
---
>       if     (mnflg.eq.0 .or. mnproc.eq.mnflg) then
604c602
<       real*4,  intent(in)    :: aa(itdm,*)
---
>       real*4,  intent(inout) :: aa(itdm,jtdm)
616a615
> c        = 0; all nodes
618,619c617,618
< c     the array aa is unchanged on exit, and need not exist
< c      on the nodes that do not reference it.
---
> c     if mnflg.ne.0 the array aa may be broadcast to all nodes,
> c      so aa must exist and be overwritable on all nodes.
637c636
<       integer i,msg,j,mp,np,mnp
---
>       integer i,j,mp,np,mnp
648,649c647
<       if     (.not.allocated(at4)) then
<         if     (mproc.eq.mpe_1(nproc)) then
---
>       if     (.not.allocated(al4)) then
651d648
<           allocate(      alt4(idm *jdm,ipr) )
653,654d649
<           call mem_stat_add( (idm *jdm*jpr)/2 ) !real*4, so /2
<         endif !first tile in the row
663a659,661
> c     use xclput for now,
> c     this is slow for mnflg.ne.0, but easy to implement.
> c
664a663,666
> c       "broadcast" row sections of aa to all processors in the row.
>         if     (mnproc.ne.mnflg) then
>           aa(:,:) = vland4
>         endif
666d667
< c       "broadcast" row sections of aa to first processor in each row.
688d688
< c       "broadcast" partial row sections to the rest of the row's processors
690c690
<           msg = 0
---
>           i = 0
692,699c692,693
<             do j= 1,jj
<               do i= 1,ii_pe(mp,nproc)
<                 alt4(i+(j-1)*ii_pe(mp,nproc),mp) = 
<      &            al4(i0_pe(mp,nproc)+i,j)
<               enddo
<             enddo
<             msg = msg + 1
<             call MPI_ISEND(alt4(1,mp),ii_pe(mp,nproc)*jj,MTYPE4,
---
>             i = i + 1
>             call MPI_ISEND(al4,itdm*jj,MTYPE4,
701,707c695
<      &                    mpi_comm_hycom, mpireqb(msg), mpierr)
<           enddo !mp
< c
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = al4(i0+i,j)
<             enddo
---
>      &                    mpi_comm_hycom, mpireqb(i), mpierr)
709,710c697
< c
<           call mpi_waitall( msg, mpireqb, MPI_STATUSES_IGNORE, mpierr)
---
>           call mpi_waitall( i, mpireqb, MPI_STATUSES_IGNORE, mpierr)
712c699
<           call MPI_RECV(at4,ii*jj,MTYPE4,
---
>           call MPI_RECV(al4,itdm*jj,MTYPE4,
715,719d701
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = at4(i+(j-1)*ii)
<             enddo
<           enddo
720a703,704
> c
>         aa(:,j0+1:j0+jj) = al4(:,1:jj)
724,726c708,709
< c       "broadcast" row sections of aa to first processor in each row.
<         if     (mproc.eq.mpe_1(nproc)) then
<           call SHMEM_GET4(al4(1,   1),
---
>         if     (mnproc.ne.mnflg) then
>           call SHMEM_GET4(aa(1,j0+1),
728,751d710
<           do mp= mpe_1(nproc)+1,mpe_e(nproc)
<             do j= 1,jj
<               do i= 1,ii
<                 alt4(i+(j-1)*ii,mp) = al4(i0+i,j)
<               enddo
<             enddo
<           enddo !mp
<         endif
<         BARRIER
< c       "broadcast" partial row sections to the rest of the row's processors
<         if     (mproc.eq.mpe_1(nproc)) then
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = al4(i0+i,j)
<             enddo
<           enddo
<         else
<           call SHMEM_GET4( at4(1,    1),
<      &                    alt4(1,mproc),ii*jj,idproc1(mpe_1(nproc)))
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = at4(i+(j-1)*ii)
<             enddo
<           enddo
755a715
> c       "broadcast" row sections of aa to all processors in the row.
757d716
< c       "broadcast" partial row sections of aa to all processors in the row.
759c718
<           msg = 0
---
>           i = 0
761,776c720,723
<             do j= 1,jj
<               do i= 1,ii_pe(mp,nproc)
<                 alt4(i+(j-1)*ii_pe(mp,nproc),mp) = 
<      &            aa(i0_pe(mp,nproc)+i,j)
<               enddo
<             enddo
<             msg = msg + 1
<             call MPI_ISEND(alt4(1,mp),ii_pe(mp,nproc)*jj,MTYPE4,
<      &                    idproc(mp,nproc), 9953,
<      &                    mpi_comm_hycom, mpireqb(msg), mpierr)
<           enddo !mp
< c
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = aa(i0+i,j)
<             enddo
---
>             i = i + 1
>             call MPI_ISEND(aa(1,j0+1),itdm*jj,MTYPE4,
>      &                    idproc(mp,nproc), 9952,
>      &                    mpi_comm_hycom, mpireqb(i), mpierr)
778,779c725
< c
<           call mpi_waitall( msg, mpireqb, MPI_STATUSES_IGNORE, mpierr)
---
>           call mpi_waitall( i, mpireqb, MPI_STATUSES_IGNORE, mpierr)
781,782c727,728
<           call MPI_RECV(at4,ii*jj,MTYPE4,
<      &                  idproc(mpe_1(nproc),nproc), 9953,
---
>           call MPI_RECV(aa(1,j0+1),itdm*jj,MTYPE4,
>      &                  idproc(mpe_1(nproc),nproc), 9952,
784,788d729
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = at4(i+(j-1)*ii)
<             enddo
<           enddo
791,801c732
< c       "broadcast" partial row sections to the rest of the row's processors
<         if     (mproc.eq.mpe_1(nproc)) then
<           do mp= mpe_1(nproc)+1,mpe_e(nproc)
<             do j= 1,jj
<               do i= 1,ii_pe(mp,nproc)
<                 alt4(i+(j-1)*ii_pe(mp,nproc),mp) = 
<      &            aa(i0_pe(mp,nproc)+i,j)
<               enddo
<             enddo
<           enddo !mp
<         endif
---
> c       assume aa is in common.
803,816c734,737
<         if     (mproc.eq.mpe_1(nproc)) then
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = aa(i0+i,j)
<             enddo
<           enddo
<         else
<           call SHMEM_GET4( at4(1,    1),
<      &                    alt4(1,mproc),ii*jj,idproc1(mpe_1(nproc)))
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = at4(i+(j-1)*ii)
<             enddo
<           enddo
---
>         if     (mproc.ne.mpe_1(nproc)) then
>           call SHMEM_GET4(aa(1,j0+1),
>      &                    aa(1,j0+1),itdm*jj,
>      &                    idproc(mpe_1(nproc),nproc))
820a742,745
> c     
>       do j= 1,jtdm
>         call xclput4(aa(1,j),itdm, a, 1,j,1,0)
>       enddo
1810a1736,1809
>       subroutine xclput4(aline,nl, a, i1,j1,iinc,jinc)
>       implicit none
> c
>       integer, intent(in)    ::  nl,i1,j1,iinc,jinc
>       real*4,  intent(in)    ::  aline(nl)
>       real*4,  intent(inout) ::  a(ii,jj)
> c
> c**********
> c*
> c  1) fill a line of elements in the non-tiled 2-D grid.
> c     Special version for xcaput4 only.
> c
> c  2) aline(i) == aa(i1+i1*(i-1),j1+j1*(i-1)), for i=1...nl.
> c     where aa is the non-tiled representation of a, and
> c     one of iinc and jinc must be 0, and the other must be 1.
> c     also updates the halo.
> c
> c  3) parameters:
> c       name            type         usage            description
> c    ----------      ----------     -------  ----------------------------
> c    aline           real           input     line of element values
> c    nl              integer        input     dimension of aline
> c    a               real           in/out    tiled target array
> c    i1              integer        input     1st non-tiled index into a
> c    j1              integer        input     2nd non-tiled index into a
> c    iinc            integer        input     1st index increment
> c    jinc            integer        input     2nd index increment
> c*
> c**********
> c
>       integer i,j
> #if defined(TIMER)
> c
>       if     (nxc.eq.0) then
>         call xctmr0( 5)
>         nxc = 5
>       endif
> #endif
> c
>       if     (jinc.eq.0) then
>         if     (j1-j0.ge.1 .and. j1-j0.le.jj) then
>           do i= max(1,i1-i0),min(i1-i0+nl-1,ii)
>             a(i,j1-j0) = aline(i+i0-i1+1)
>           enddo
>           if     (nreg.ne.0 .and.
>      &            i0.eq.0 .and. i1+nl-1.ge.itdm+1) then  ! periodic
>             do i= max(itdm+1,i1),i1+nl-1
>               a(i-itdm,j1-j0) = aline(i)
>             enddo
>           endif
>         endif
>       elseif (iinc.eq.0) then
>         if     (i1-i0.ge.1 .and. i1-i0.le.ii) then
>           do j= max(1,j1-j0),min(j1-j0+nl-1,jj)
>             a(i1-i0,j) = aline(j+j0-j1+1)
>           enddo
>         endif
>         if     (nreg.ne.0 .and.
>      &          i0.eq.0 .and. i1.ge.itdm+1) then       ! periodic
>           do j= max(1,j1-j0),min(j1-j0+nl-1,jj)
>             a(i1-itdm,j) = aline(j+j0-j1+1)
>           enddo
>         endif
>       endif
> #if defined(TIMER)
> c
>       if     (nxc.eq. 5) then
>         call xctmr1( 5)
>         nxc = 0
>       endif
> #endif
>       return
>       end subroutine xclput4
> 
4926d4924
<       character*16 cmnproc
4988a4987
>         write(lp,*)
4991,5001d4989
<       if     (nproc.eq.2 .and. mproc.eq.mpe_1(nproc)) then
<         write(cmnproc,'(a,i6,a)') 'processor',mnproc,':'
<         call mem_stat_print(cmnproc)
<       endif
<       call xcsync(flush_lp)
<       if     (mnproc.eq.ijpr) then
<         write(cmnproc,'(a,i6,a)') 'processor',mnproc,':'
<         call mem_stat_print(cmnproc)
<         write(lp,*)
<       endif
<       call xcsync(flush_lp)
5047d5034
<       character*16 cmnproc
5141,5150d5127
<       endif !mnproc.eq.1
<       call xcsync(flush_lp)
<       if     (nproc.eq.2 .and. mproc.eq.mpe_1(nproc)) then
<         write(cmnproc,'(a,i6,a)') 'processor',mnproc,':'
<         call mem_stat_print(cmnproc)
<       endif
<       call xcsync(flush_lp)
<       if     (mnproc.eq.ijpr) then
<         write(cmnproc,'(a,i6,a)') 'processor',mnproc,':'
<         call mem_stat_print(cmnproc)
5152c5129
<       endif
---
>       endif !mnproc.eq.1
5194d5170
< c> Feb. 2015 - reduced buffering memory requirements
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_xc_sm.h ../hycom_97WI
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_za_mp1.h ../hycom_97WI
567,569d566
< c
< c --- w on 1st tile only
< c
575d571
<       if     (mnproc.eq.1) then
578,587d573
<       else
<         allocate( w(1),     wminy(jtdm),wmaxy(jtdm),htmp(idm*jdm) )
<         call mem_stat_add( (     1+2*jtdm+idm*jdm)/2) !real*4, so /2
<       endif !1st tile:else
< #else
<       if     (mnproc.eq.1) then
<         allocate( w(n2drec) )
<       else
<         allocate( w(1) )
<       endif !1st tile:else
1422,1426d1407
< c
< c
< c> Revision history:
< c>
< c> Feb  2015 - w on 1st tile only
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_za_mp.h ../hycom_97WI
97a98
> c --- n2drec = size of output 2-d array, multiple of 4096
244a246
> c --- n2drec = size of output 2-d array, multiple of 4096
400a403
> c --- n2drec = size of output 2-d array, multiple of 4096
636,659c639,640
<       allocate( wminy(jdm),wmaxy(jdm),htmp(idm*jdm) )
<       call mem_stat_add( (2*jdm+idm*jdm)/2 ) !real*4, so /2
< c
<       if     (mproc.eq.mp_1st) then
<         if     (nproc.ne.jpr) then
<           allocate( w(itdm*jj) )
<           call mem_stat_add( (itdm*jj)/2 ) !real*4, so /2
<         else
<           allocate( w(itdm*jj+n2drec-itdm*jtdm) )
<           call mem_stat_add( (itdm*jj+n2drec-itdm*jtdm)/2 ) !real*4, so /2
<         endif
<       else
<         allocate( w(1) )
<       endif
< #else
<       if     (mproc.eq.mp_1st) then
<         if     (nproc.ne.jpr) then
<           allocate( w(itdm*jj) )
<         else
<           allocate( w(itdm*jj+n2drec-itdm*jtdm) )
<         endif
<       else
<         allocate( w(1) )
<       endif
---
>       allocate( w(n2drec),wminy(jtdm),wmaxy(jtdm),htmp(idm*jdm) )
>       call mem_stat_add( (n2drec+2*jtdm+idm*jdm)/2 ) !real*4, so /2
1006c987
<      &                      w(1),
---
>      &                      w(1+j0*itdm),
1023c1004
<         do j= 1,jj
---
>         do j= j0+1,j0+jj
1036,1037c1017,1018
<         wmin = minval(wminy(1:jj))
<         wmax = maxval(wmaxy(1:jj))
---
>         wmin = minval(wminy(j0+1:j0+jj))
>         wmax = maxval(wmaxy(j0+1:j0+jj))
1411c1392
<             w(itdm*jj+i-itdm*jtdm) = data_void(1)
---
>             w(i) = data_void(1)
1423c1404
<      &                         w(1),
---
>      &                         w(1+itdm*j0),
1453d1433
< c> Feb  2015 - reduced size of w, allocated on 1st tile in each row only
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_za_sm.h ../hycom_97WI
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_za_zt.h ../hycom_97WI
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw stmt_fns.h ../hycom_97WI
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw unit_offset.h ../hycom_97WI
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw machi_c.c ../hycom_97WI
end
foreach f ( *.f *.F )
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw bigrid.f ../hycom_97WI/bigrid.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw forfun.f ../hycom_97WI/forfun.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw inigiss.f ../hycom_97WI/inigiss.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw inikpp.f ../hycom_97WI/inikpp.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw inimy.f ../hycom_97WI/inimy.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw matinv.f ../hycom_97WI/matinv.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw poflat.f ../hycom_97WI/poflat.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw prtmsk.f ../hycom_97WI/prtmsk.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw psmoo.f ../hycom_97WI/psmoo.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw restart.f ../hycom_97WI/restart.f
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw barotp.F ../hycom_97WI/barotp.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw blkdat.F ../hycom_97WI/blkdat.F
30,37d29
< #elif defined(OCEANS2)
<       if     (nocean.eq.2) then
< c ---   slave HYCOM works from ./OCEAN2
<         flnminp = './OCEAN2/'
<       else
< c ---   master HYCOM
<         flnminp = './'
<       endif
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw cnuity.F ../hycom_97WI/cnuity.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw convec.F ../hycom_97WI/convec.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw diapfl.F ../hycom_97WI/diapfl.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw dpthuv.F ../hycom_97WI/dpthuv.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw dpudpv.F ../hycom_97WI/dpudpv.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw geopar.F ../hycom_97WI/geopar.F
144,152d143
< #elif defined(ENABLE_ATM)
< c         pang
<           i = index(cline,'=')
<           read (cline(i+1:),*) hminb,hmaxb
<           if     (mnproc.eq.1) then
<           write (lp,'(a)') trim(cline)
<           endif
<           call xcsync(flush_lp)
<           call zaiord(pang, ip,.false., hmina,hmaxa, 9)
286,288d276
< #if defined(ENABLE_ATM)
<       call xctilr(pang,  1,1, nbdy,nbdy, halo_ps)
< #endif
864d851
< c> Feb. 2015 - added pang for coupled cases
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw hybgen.F ../hycom_97WI/hybgen.F
904,906c904,905
< c ---           if layer k+1 is too dense, thicken the thinner of the 
< c ---           two, i.e. skip this layer (never get here) if it is not 
< c ---           thinner than the other.
---
> c ---           if layer k+1 is too dense, thicken the thinner of the two,
> c ---           i.e. skip this layer if it is not thinner than the other.
924,927c923,925
< c ---           if layer k+1, or layer k+2, does not touch the bottom
< c ---           then maintain minimum thicknesses of layers k and k+1 as
< c ---           much as possible. otherwise, permit layers to collapse
< c ---           to zero thickness at the bottom.  
---
> c ---           if layer k+1 does not touch the bottom then maintain minimum
> c ---           thicknesses of layers k and k+1 as much as possible,
> c ---           but permit layers to collapse to zero thickness at the bottom
929c927
<                 if     (p(i,j,k+3).lt.p(i,j,kk+1)) then
---
>                 if     (p(i,j,k+2).lt.p(i,j,kk+1)) then
966c964
< cdiag&             'hybgen, min. thknss (k+):',k-1,p(i,j,k)*qonem
---
> cdiag&             'hybgen, min. thknss (k+):',k,p(i,j,k+1)*qonem
2618d2615
< c> Feb. 2015 - when too light, include layer k+2 in "near bottom" logic
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw hycom_cice.F ../hycom_97WI/hycom_cice.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw hycom.F ../hycom_97WI/hycom.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw icloan.F ../hycom_97WI/icloan.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw inicon.F ../hycom_97WI/inicon.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw isnan.F ../hycom_97WI/isnan.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw latbdy.F ../hycom_97WI/latbdy.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw machine.F ../hycom_97WI/machine.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_archiv.F ../hycom_97WI/mod_archiv.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_cb_arrays.F ../hycom_97WI/mod_cb_arrays.F
116d115
<      & pang,          ! angle between xwards and ewards
942d940
<      &          pang(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
990c988
<       call mem_stat_add( 60*(idm+2*nbdy)*(jdm+2*nbdy) )
---
>       call mem_stat_add( 59*(idm+2*nbdy)*(jdm+2*nbdy) )
1004d1001
<                 pang = r_init
1464d1460
< c> Feb  2015 - added pang for coupled cases
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_dimensions.F ../hycom_97WI/mod_dimensions.F
200a201
> c      print *,'now, high = ',mem_alloc_now,mem_alloc_high
212c213
<       real*8    a3_1,a3_now,a3_high,gb_now,gb_high
---
>       real*8    a3_1,a3_now,a3_high
215,217d215
<       gb_now  = mem_alloc_now  / (1024.d0**3/8.d0)
<       gb_high = mem_alloc_high / (1024.d0**3/8.d0)
< c
230c228
<       write(lp,'(/a,a,2i16/a,a,4x,2f16.3/a,a,4x,2f16.3/)')
---
>       write(lp,'(/a,a,2i16/a,a,4x,2f16.3/)')
233,234d230
<      &  trim(ctitle),' memory (GB)    now,high =',
<      &  gb_now,gb_high,
277d272
< c> Feb. 2015 - added gb_now,gb_high
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_floats.F ../hycom_97WI/mod_floats.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_hycom.F ../hycom_97WI/mod_hycom.F
1196,1203d1195
<       if (mnproc.eq.1) then
<         call mem_stat_print('  zaiost  1st:')
<       endif !1st tile
<       call xcsync(flush_lp)
<       if (mnproc.eq.ijpr) then
<         call mem_stat_print('  zaiost last:')
<       endif !last tile
<       call xcsync(flush_lp)
1221c1213
< *       write(6,'("Case 1 ddsurf =",G25.17)')ddsurf
---
>         write(6,'("Case 1 ddsurf =",G25.17)')ddsurf
1225c1217
< *       write(6,'("Case 1 ddsurf =",G25.17)')ddsurf
---
>         write(6,'("Case 1 ddsurf =",G25.17)')ddsurf
1459c1451
<       dtime=(nstep1/nts_day)+mod(nstep1,nts_day)*(baclin/86400.0d0)
---
>       dtime=nstep1/(86400.0d0/baclin)
1464c1456
<       dtime=(nstep2/nts_day)+mod(nstep2,nts_day)*(baclin/86400.0d0)
---
>       dtime=nstep2/(86400.0d0/baclin)
1573c1565
<         dtime0=(nstep0/nts_day)+mod(nstep0,nts_day)*(baclin/86400.0d0)
---
>         dtime0=nstep0/(86400.0d0/baclin)
1647,1648d1638
<         surflx(:,:) = 0.0
<         salflx(:,:) = 0.0
1650c1640
<         dtime0=(nstep0/nts_day)+mod(nstep0,nts_day)*(baclin/86400.0d0)
---
>         dtime0=nstep0/(86400.0d0/baclin)
1728d1717
<       nstep = nstep0+1  !for pipe_compare
1738d1726
<                 dpbbl(i,j)=thkbot*onem
1789d1776
<       nstep = nstep-1  !restore
1836c1823
<       open (unit=nod,file=trim(flnminp)//'summary_out',status='unknown')
---
>       open (unit=nod,file='summary_out',status='unknown')
2112,2116d2098
< c
< c --- Report
<       call ESMF_LogWrite("HYCOM initialize routine returned",
<      &     ESMF_LOG_INFO, rc=rc)
<       call ESMF_LogFlush(rc=rc)
2125a2108,2112
> c --- Report
>       call ESMF_LogWrite("HYCOM initialize routine returned",
>      &     ESMF_LOG_INFO, rc=rc)
>       call ESMF_LogFlush(rc=rc)
> c
2254c2241
<       dtime=(nstep/nts_day)+mod(nstep,nts_day)*(baclin/86400.0d0)
---
>       dtime=dtime0+(nstep-nstep0)/(86400.0d0/baclin)
2458,2459c2445
<          call pipe_comparall(n,m, 'ENTERm, step')
<          call pipe_comparall(m,n, 'ENTERn, step')
---
>          call pipe_comparall(m,n, 'ENTER , step')
3637,3638d3622
<         call dpthuv
< c
3644d3627
<         nstep = nstep+1  !for pipe_compare
3672,3687d3654
<         nstep = nstep-1  !restore
< c
< c ---   update montg to preserve bit for bit reproducability on restart
<         m=mod(nstep  ,2)+1
<         n=mod(nstep+1,2)+1
<         if     (meanfq.ne.0.0) then
< c ---     assume meanfq not changed to zero when rerun from restart
<           call momtum_hs(n,m)
<           surflx(:,:) = 0.0
<           salflx(:,:) = 0.0
<           if     (histmn) then
<             call mean_zero(dtime)
<             call mean_add(n, 0.5)
<           endif  ! histmn
<         endif !meanfq
<         call momtum_hs(n,m)
3822,3823d3788
< c> Feb. 2015 - removed dtime0 from calculation of dtime
< c> Feb. 2015 - fixed issues with bit for bit reproducability on restart
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_incupd.F ../hycom_97WI/mod_incupd.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_mean.F ../hycom_97WI/mod_mean.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_momtum.F ../hycom_97WI/mod_momtum.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_OICPL.F ../hycom_97WI/mod_OICPL.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_pipe.F ../hycom_97WI/mod_pipe.F
8,9c8
<       integer, save, private :: ipunit,lpunit,ishift,jshift,nsym,
<      &                          nstep_start
---
>       integer, save, private :: ipunit,lpunit,ishift,jshift,nsym
118d116
<       logical       ltstep
181,191d178
<       if     (lpipeio) then
<         inquire(file=trim(flnminp)//'PIPE_START',   exist=ltstep)
<         if     (ltstep) then
<           open(unit=uoff+99,file=trim(flnminp)//'PIPE_START')  !on all nodes
<           read(uoff+99,*) nstep_start
<           close(unit=uoff+99) !file='PIPE_START'
<         else
<           nstep_start = 0
<         endif
<       endif
< c
330d316
<       use mod_cb_arrays  ! HYCOM saved arrays, for nstep
349c335
<       if (lpipeio .and. nstep.ge.nstep_start) then
---
>       if (lpipeio) then
431c417
<       if (lpipeio .and. nstep.ge.nstep_start) then
---
>       if (lpipeio) then
1418,1419c1404,1405
<           txt1(1:9) = '...u(kn) '
<           txt2(1:9) = '...v(kn) '
---
>           txt1(1:9) = 'u(kn)  k='
>           txt2(1:9) = 'v(kn)  k='
1422,1426c1408
<           txt1(1:9) = '.dpu(kn) '
<           txt2(1:9) = '.dpv(kn) '
<           call pipe_compare_sym2( dpu(1-nbdy,1-nbdy,k,n),iu,txt1,
<      &                            dpv(1-nbdy,1-nbdy,k,n),iv,txt2)
<           txt1(1:9) = '..dp(kn) '
---
>           txt1(1:9) = 'dp(kn) k='
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_stokes.F ../hycom_97WI/mod_stokes.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_tides.F ../hycom_97WI/mod_tides.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_tsadvc.F ../hycom_97WI/mod_tsadvc.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_xc.F ../hycom_97WI/mod_xc.F
113,114c113
<      &   al4,  ! xcaget4 and xcaput4
<      &   alt4  ! xcaget4 and xcaput4
---
>      &   al4   ! xcaget4 and xcaput4
131,132d129
<       real*4, save, private, dimension(idm*jdm,jpr) ::
<      &   alt4  ! xcaget4 and xcaput4
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mod_za.F ../hycom_97WI/mod_za.F
25c25
<      &           wminy,wmaxy,htmp
---
>      &           w,wminy,wmaxy,htmp
28a29
>       real*4,  private, save, dimension(n2drec)  :: w
32,33d32
< c
<       real*4,  private, save, allocatable, dimension(:) :: w
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mxkprf.F ../hycom_97WI/mxkprf.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mxkrt.F ../hycom_97WI/mxkrt.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mxkrtm.F ../hycom_97WI/mxkrtm.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw mxpwp.F ../hycom_97WI/mxpwp.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw overtn.F ../hycom_97WI/overtn.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw thermf.F ../hycom_97WI/thermf.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw trcupd.F ../hycom_97WI/trcupd.F
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw wtime.F ../hycom_97WI/wtime.F
end
